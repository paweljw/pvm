# 0, add number of iterations onto stack
PUSH 100
# 2, move number of iterations into register 0
RPOP 0
# 4, push current indicator onto stack
PUSH 1
# 6, move indicator into register 1
RPOP 1
# 8, loop begin

# Put 0 in register 2
PUSH 0
# 10
RPOP 2

# 12, pop data into buffer
RPUSH 1

# 14 put 3 on stack
PUSH 3
# 16 put X mod 3 on stack
MOD
# 17 if true (modulo failed) jump ahead
JUMPT 39
# 19
PUSH 1
# 21
RPOP 2
# 23 push Fizz
PUSH 122 PUSH 122 PUSH 105 PUSH 70
# 31 print fizz
PRINTA POP PRINTA POP PRINTA POP PRINTA POP

# 39 push number onto stack again
RPUSH 1
# 41 push 5 for comparison
PUSH 5
# 43 put X mod 5 on stack
MOD
# 44 if true (modulo failed) jump ahead
JUMPT 66
# 46 put flag on stack
PUSH 1
# 48 put flag into register
RPOP 2
# 50 push Buzz
PUSH 122 PUSH 122 PUSH 117 PUSH 66
# 58 print Buzz
PRINTA POP PRINTA POP PRINTA POP PRINTA POP
# 66 put flag onto stack
RPUSH 2
# 68 put comparison value onto stack
PUSH 1
# 70 compare
EQ
# 71
JUMPT 77
# 73, push value on stack AGAIN
RPUSH 1
# 75 print and pop
PRINT
# 76
POP


# 77 Push register value onto stack
RPUSH 1
# 78 push subtraction second operand onto stack
PUSH 1
# 81
ADD
# 82
RCPY 1

PUSH 10
PRINTA
POP

# 84 Add comparison source onto stack
PUSH 100
# 86
EQ
# 87 If iterator not equal to 100, jump back to instruction 8
JUMPF 8
